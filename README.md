# 🏆 C++ Coding Test Ultimate Cheat Sheet

</br>

## 📌 목차 (Table of Contents)
1. [입력 크기(N)에 따른 알고리즘 선택](#1-입력-크기n에-따른-알고리즘-선택)
2. [자료구조 & STL](#2-자료구조--stl)
3. [알고리즘 판단 및 전략수립](#3-알고리즘-판단-및-전략수립)
4. [구현 테크닉 & 최적화 기법](#4-구현-테크닉--최적화-기법)
5. [자주 하는 실수 & 디버깅 체크리스트](#5-자주-하는-실수--디버깅-체크리스트)

</br></br>

## 1. 입력 크기(N)에 따른 알고리즘 선택
제한 시간 1초(약 1억 번 연산) 기준, $N$의 크기를 통해 허용되는 시간 복잡도를 역산하여 알고리즘을 선택한다.

| N의 범위 | 허용 시간 복잡도 | 추천 알고리즘 |
| :--- | :--- | :--- |
| **$N \le 20$** | $O(N!)$, $O(2^N)$ | 완전 탐색(Backtracking), 재귀, 비트마스킹 |
| **$N \le 100$** | $O(N^4)$ | 플로이드-워셜 |
| **$N \le 1,000$** | $O(N^3)$, $O(N^2)$ | 2차원 DP, 벨만-포드, DFS/BFS (행렬) |
| **$N \le 10,000$** | $O(N^2)$ | 단순 정렬( $O(N^2)$ ), 2중 Loop, 다익스트라(인접행렬) |
| **$N \le 100,000$** | $O(N \log N)$, $O(N)$ | **고속 정렬, 이분 탐색, 다익스트라(PQ), 유니온-파인드**, 그리디 |
| **$N \le 1,000,000$** | $O(N)$, $O(\log N)$ | 투 포인터, DP, 위상 정렬, KMP/Rabin-Karp |
| **$N \ge 10억$** | $O(\log N)$, $O(1)$ | 수학적 접근, DP(Map 활용), 이분 탐색 |

</br></br>

## 2. 자료구조 & STL

<details>
<summary><b>STL</b></summary>
<br>
  
<details>
  <summary>(1) 성능 비교: List vs Queue</summary>
  <br>
  `std::list`와 `std::queue`는 시간 복잡도가 같아 보이지만, **메모리 구조** 때문에 실제 성능 차이가 크다.

  * **`std::queue` (deque 기반)**: 데이터가 블록 단위로 연속 배치되어 **Cache Hit** 비율이 높고 빠르다. (권장)
  * **`std::list`**: 노드가 힙 메모리에 흩어져 있어 **Cache Miss**가 잦아 느리다. 특별한 이유가 없다면 사용을 지양한다.
</details>

<details>
<summary>(2) 빈번한 삽입/삭제 처리</summary>
<br>
* 벡터(`vector`)나 큐(`queue`)는 중간 요소를 삽입/삭제할 때 $O(N)$이 소요된다.
* **리스트의 중간 위치**에서 삽입과 삭제가 매우 빈번하게 발생하는 문제에 한하여, $O(1)$ 처리가 가능한 **연결 리스트(Linked List)** 또는 **스택(Stack)** 구조를 활용하는 것이 적합하다.
</details>

</details>

<details>
<summary><b>그래프</b></summary>
<br>

**1. 그래프 표현 방식 (Graph Representation)**
* **희소 그래프 (Sparse Graph)**: 간선의 개수가 적은 경우 ($E \ll V^2$)
  $\rightarrow$ **인접 리스트 (`vector<vector<int>>`)** 사용 (메모리 절약)
* **밀집 그래프 (Dense Graph)**: 간선이 많거나 플로이드-워셜 알고리즘
  $\rightarrow$ **인접 행렬 (`int adj[N][N]`)** 사용 ($O(1)$ 접근 속도 활용)

<br>

**2. 메모리 최적화 (Memory Optimization)**
* **Visited 배열 생략**: 2차원 그리드 탐색(BFS/DFS) 시 원본 배열 수정이 가능하다면, 방문한 위치의 값을 직접 변경(예: `'1'` $\to$ `'0'`)하여 **`visited` 배열 메모리($O(NM)$)를 절약**할 수 있다.

</details>
</br></br>

## 3. 알고리즘 판단 및 전략수립

<details>
<summary><b>그래프 탐색 및 모델링 전략 (Graph Strategy)</b></summary>
<br>

**1. 보이지 않는 그래프 (Implicit Graph)**

| 핵심 | 내용 |
| :--- | :--- |
| **정의** | **"상태(State)를 노드로, 변화(Transition)를 간선으로 정의하면 무엇이든 그래프로 만들 수 있다."** |
| **적용** | 2차원 맵이 없어도 **현재 상황(숫자, 좌표)**을 정점으로, **규칙**을 간선으로 보아 BFS로 변환 가능 |

<br>

**2. 탐색 방식 선택 가이드**

| 기준 | 추천 알고리즘 | 설명/이유 |
| :--- | :---: | :--- |
| **노드 수 ($N$)** | **DFS** ($N \le 1,000$)<br>**BFS** ($N \ge 10,000$) | DFS: 구현 간결성<br>BFS: 스택 오버플로우 방지 및 최단 거리 보장 |
| **목적 (Output)** | **Union-Find**<br>**BFS** | 단순 영역/집합 구분 (가장 효율적)<br>최단 거리/경로 추적 |
| **메모리 효율** | **DFS** | 경로 끝까지 가는 완전 탐색 시 압도적으로 유리<br>(BFS는 큐에 $2^N$까지 쌓여 터질 수 있음) |

<br>

**3. Multi-source BFS (동시 시작)**

| 구분 | 내용 |
| :--- | :--- |
| **상황** | 불, 바이러스 등 **여러 지점에서 동시에** 확산될 때 |
| **구현** | 시작점들을 **초기에 모두 큐에 넣고(Push)** BFS를 **단 한 번** 수행 |
| **효율성** | 각 시작점 반복 $O(K \times NM)$ $\to$ **$O(NM)$** 으로 최적화 |

<br>

**4. 단방향 그래프의 왕복 최단 거리 (Reverse Graph Strategy)**

| 구분 | 내용 |
| :--- | :--- |
| **최적화 전략**<br>(Insight) | 1. **정방향 그래프**: $X$ 출발 $\rightarrow$ **($X \to i$, 오는 길)**<br>2. **역방향 그래프**: $X$ 출발 $\rightarrow$ 논리적 **($i \to X$, 가는 길)**<br><br>  |
| **효과** | 다익스트라 **단 2회** 수행. 시간 복잡도 $O(M \log N)$으로 단축 |

</details>

<details>
<summary><b>완전 탐색 (Brute Force & Backtracking)</b></summary>
<br>

완전 탐색은 입력 크기($N$)가 작을 때 확실한 해답을 보장한다.

**1. 구현 방식**
* **단순 반복문**: $N$중 `for`/`while`문 사용.
* **재귀 (Backtracking)**:
  * **순열 (Permutation)**: 순서 중요 ($A, B \ne B, A$) $\to$ `next_permutation` 또는 `visited` 배열 사용.
  * **조합 (Combination)**: 순서 무관 ($A, B = B, A$) $\to$ `start` 인덱스를 인자로 넘겨 중복 방지.
* **비트마스킹 (Bitmasking)**: 집합의 포함 여부를 비트(`0`, `1`)로 관리하여 메모리와 연산 속도 최적화.

</details>

<details>
<summary><b>시뮬레이션 및 수열 전략 (Simulation & Math)</b></summary>
<br>

**1. 원형 순환 (Josephus Problem) 전략**
* **제거되는 순서**가 필요한 경우 $\rightarrow$ **Simulation**
  * $N$이 작음 (5,000 이하): **Queue** 시뮬레이션.
  * $K$가 매우 큼 (10억 이상): **Vector + Modulo(%) 연산** (Queue 반복 시 시간 초과).
* **마지막 남는 하나**만 필요한 경우 $\rightarrow$ **DP / Math** ($O(N)$ 점화식 활용).

</details>

</br></br>

## 4. 구현 테크닉 & 최적화 기법

<details>
<summary><b>백트래킹(Backtracking) 성능 최적화</b></summary>
<br>

백트래킹 알고리즘의 성능은 **1. 탐색 공간의 최소화**와 **2. 유망성 검사(Pruning) 비용의 최적화**에 의해 결정된다.

* **Space-Time Trade-off (N-Queen 예시)**
    * 반복문(`for`)을 통해 유망성을 검사하면 $O(N)$이 소요되어 비효율적이다.
    * **3가지 조건(열, 좌상향 대각선, 우상향 대각선)을 배열에 미리 매핑**하여 검사 비용을 **$O(1)$**로 단축할 수 있다.
* **비트마스킹 (Bitmasking)**
    * `bool` 배열 대신 비트(Bit)를 활용하면 메모리 사용량을 최소화할 수 있으며, 비트 연산을 통해 처리 속도를 더욱 높일 수 있다.

</details>

<details>
<summary><b> 2차원 배열의 1차원화 테크닉 (Optimization)</b></summary>
<br>

2차원 좌표 $(r, c)$를 1차원 인덱스 $k$로 변환하여 탐색하면, **중복 없는 조합(Combination)** 구현이 매우 쉬워진다.

* **변환 공식**: $M$은 2차원 배열의 가로 길이(열의 개수)
    * **1D to 2D**: $r = k / M$, $c = k \% M$
    * **2D to 1D**: $k = r \times M + c$
* **활용 (백트래킹 조합 최적화)**
    * `start` 인덱스를 인자로 받아 `for (int k = start; k < N*M; ++k)` 반복문 하나로 처리.
    * 이전 위치 재방문 방지 및 중복 검사 로직($visited$) 제거로 실행 속도 대폭 향상 (약 $3! = 6$배).

</details>

<details>
<summary><b>모듈러(%) 연산 인덱스 처리</b></summary>
<br>

* 대부분의 모듈러 연산은 0부터 시작하는 인덱스(0-based Index)에서 예외 없이 깔끔하게 작동한다.
* 문제에서 대상이 1번부터 시작하더라도, 내부 로직에서는 $0 \sim N-1$로 변환하여 처리하고, 최종 출력 시에만 $+1$을 해주는 것이 인덱스 계산 실수를 줄이는 방법이다.

</details>

</br></br>

## 5. 자주 하는 실수 & 디버깅 체크리스트

- [ ] **BFS 방문 처리 시점**: 방문 처리는 반드시 **"큐에 넣을 때(Push)"** 수행해야 한다.
    * 큐에서 꺼낼 때(Pop) 처리할 경우, 동일한 노드가 큐에 중복되어 삽입될 수 있으며 이는 메모리 초과 및 시간 초과의 원인이 된다.
- [ ] **인덱스 오프셋 오류**: "K번째"라는 말이 나올 때 arr[K]가 아니라 arr[K-1]인지, 혹은 입력을 1-based로 받고 0-based로 변환했는지 확인한다.
- [ ] **배열 크기 및 경계값 오류**

</details>
