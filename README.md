# 🏆 C++ Coding Test Ultimate Cheat Sheet

</br>

## 📌 목차 (Table of Contents)
1. [입력 크기(N)에 따른 알고리즘 선택](#1-입력-크기n에-따른-알고리즘-선택)
2. [자료구조 & STL 필살기](#2-자료구조--stl-필살기)
3. [알고리즘 판단 순서도 (Decision Tree)](#3-알고리즘-판단-순서도-decision-tree)
4. [C++ 필수 문법 & 템플릿 (최적화 기법)](#4-c-필수-문법--템플릿-최적화-기법)
5. [자주 하는 실수 & 디버깅 체크리스트](#5-자주-하는-실수--디버깅-체크리스트)

</br></br>

## 1. 입력 크기(N)에 따른 알고리즘 선택
제한 시간 1초(약 1억 번 연산) 기준, $N$의 크기를 통해 허용되는 시간 복잡도를 역산하여 알고리즘을 선택한다.

| N의 범위 | 허용 시간 복잡도 | 추천 알고리즘 |
| :--- | :--- | :--- |
| **$N \le 20$** | $O(N!)$, $O(2^N)$ | 완전 탐색(Backtracking), 재귀, 비트마스킹 |
| **$N \le 100$** | $O(N^4)$ | 플로이드-워셜 |
| **$N \le 1,000$** | $O(N^3)$, $O(N^2)$ | 2차원 DP, 벨만-포드, DFS/BFS (행렬) |
| **$N \le 10,000$** | $O(N^2)$ | 단순 정렬( $O(N^2)$ ), 2중 Loop, 다익스트라(인접행렬) |
| **$N \le 100,000$** | $O(N \log N)$, $O(N)$ | **고속 정렬, 이분 탐색, 다익스트라(PQ), 유니온-파인드**, 그리디 |
| **$N \le 1,000,000$** | $O(N)$, $O(\log N)$ | 투 포인터, DP, 위상 정렬, KMP/Rabin-Karp |
| **$N \ge 10억$** | $O(\log N)$, $O(1)$ | 수학적 접근, DP(Map 활용), 이분 탐색 |

</br></br>

## 2. 자료구조 & STL 필살기

<details>
<summary><b>그래프 표현 방식 (Graph Representation)</b></summary>
<br>

문제의 그래프 특성에 따라 메모리와 속도 효율이 다른 자료구조를 선택해야 한다.
* **희소 그래프 (Sparse Graph)**: 간선의 개수가 적은 경우</br>
  $\rightarrow$ **인접 리스트 (`vector<vector<int>>`)** 사용 (불필요한 메모리 낭비 방지)
* **밀집 그래프 (Dense Graph) / 플로이드-워셜**: 간선이 많거나 모든 정점 쌍의 경로가 필요한 경우</br>
  $\rightarrow$ **인접 행렬 (`int adj[N][N]`)** 사용 ($O(1)$ 접근 속도 활용)

</details>

<details>
<summary><b>STL 성능 비교: List vs Queue</b></summary>
<br>

`std::list`와 `std::queue`는 논리적 시간 복잡도가 동일하더라도, **메모리 구조의 차이**로 인해 실제 실행 속도에서 큰 차이를 보인다.

* **`std::list`**: 각 노드가 힙 메모리에 개별적으로 할당되어 메모리 구조가 불연속적이다. 이는 **Cache Miss**를 빈번하게 유발하여 실행 속도를 저하시킨다.
* **`std::queue` (deque 기반)**: 데이터를 청크(Chunk) 또는 블록 단위로 관리하여 데이터가 연속적으로 배치된다. 따라서 **Cache Hit** 비율이 높아 `list`보다 실제 처리 속도가 빠르다.

</details>

<details>
<summary><b>빈번한 삽입/삭제 처리</b></summary>
<br>

* 리스트의 중간 위치에서 삽입과 삭제가 매우 빈번하게 발생하는 경우에 한하여, $O(1)$ 처리가 가능한 **연결 리스트(Linked List)** 또는 **스택(Stack)** 구조를 활용하는 것이 적합하다.

</details>

<details>
<summary><b>메모리 최적화 팁 (Memory Optimization)</b></summary>
<br>

* **Visited 배열 생략**: 2차원 그리드 탐색(BFS/DFS) 문제에서 원본 배열을 수정해도 되는 경우, 방문한 위치의 값을 직접 변경(예: `'1'` $\to$ `'0'`)하면 별도의 `visited` 배열( $O(NM)$ ) 메모리를 절약할 수 있다.

</details>

</br></br>

## 3. 알고리즘 판단 순서도 (Decision Tree)

<details>
<summary><b>그래프 탐색 및 순회 (Graph Traversal)</b></summary>
<br>

1. **노드 개수($N$)에 따른 탐색 방식 선택**
    * $N \le 1,000$: **DFS** 사용 (구현의 간결성).
    * $N \ge 10,000$: **BFS** 사용 (재귀 호출로 인한 스택 오버플로우 방지).

2. **문제의 요구사항 (Output Type)**
    * 단순 영역의 개수 파악 / 집합 관리: **Union-Find** (가장 효율적).
    * 구체적인 경로 추적 / 최단 거리 산출: **BFS** (최단 경로 보장 및 경로 복원 용이).

</details>

<details>
<summary><b>원형 순환 및 수열 문제 (Circular & Sequence)</b></summary>
<br>

1. **원형 순환 (Circular / Josephus) 문제 전략**
    * **제거되는 순서**가 필요한 경우 $\rightarrow$ **Simulation**
        * $N$이 작음 (5,000 이하): **Queue**를 이용한 시뮬레이션.
        * $N$은 적당하나 점프 크기($K$)가 매우 큼 (10억 이상): **Vector + Modulo(%) 연산** 활용 (Queue 반복 시 시간 초과 발생).
    * **마지막에 남는 하나**만 필요한 경우 $\rightarrow$ **DP / Math** ($O(N)$ 점화식 활용).

</details>

</br></br>

## 4. C++ 필수 문법 & 템플릿 (최적화 기법)

<details>
<summary><b>백트래킹(Backtracking) 성능 최적화</b></summary>
<br>

백트래킹 알고리즘의 성능은 **1. 탐색 공간의 최소화**와 **2. 유망성 검사(Pruning) 비용의 최적화**에 의해 결정된다.

* **Space-Time Trade-off (N-Queen 예시)**
    * 반복문(`for`)을 통해 유망성을 검사하면 $O(N)$이 소요되어 비효율적이다.
    * **3가지 조건(열, 좌상향 대각선, 우상향 대각선)을 배열에 미리 매핑**하여 검사 비용을 **$O(1)$**로 단축할 수 있다.
* **비트마스킹 (Bitmasking)**
    * `bool` 배열 대신 비트(Bit)를 활용하면 메모리 사용량을 최소화할 수 있으며, 비트 연산을 통해 처리 속도를 더욱 높일 수 있다.

</details>

<details>
<summary><b>모듈러(%) 연산 인덱스 처리</b></summary>
<br>

* 대부분의 모듈러 연산은 0부터 시작하는 인덱스(0-based Index)에서 예외 없이 깔끔하게 작동한다.
* 문제에서 대상이 1번부터 시작하더라도, 내부 로직에서는 $0 \sim N-1$로 변환하여 처리하고, 최종 출력 시에만 $+1$을 해주는 것이 인덱스 계산 실수를 줄이는 방법이다.

</details>

</br></br>

## 5. 자주 하는 실수 & 디버깅 체크리스트

<details>
<summary><b>실수 & 디버깅 체크리스트 확인하기</b></summary>
<br>

- [ ] **BFS 방문 처리 시점**: 방문 처리는 반드시 **"큐에 넣을 때(Push)"** 수행해야 한다.
    * 큐에서 꺼낼 때(Pop) 처리할 경우, 동일한 노드가 큐에 중복되어 삽입될 수 있으며 이는 메모리 초과 및 시간 초과의 원인이 된다.
- [ ] **자료구조 선택 오류**: 편의성을 이유로 무분별하게 `std::list`를 사용하지 않았는지 확인해야 한다.
    * 데이터의 지역성(Locality)과 캐시 효율을 고려하여 `std::vector`나 `std::queue`를 우선적으로 고려해야 한다.
- [ ] **인덱스 오프셋 오류**: 모듈러 연산이나 원형 큐 구현 시, 1-based index를 억지로 사용하려다 오프셋 에러가 발생하지 않았는지 점검한다. ($0$-based 권장)

</details>
